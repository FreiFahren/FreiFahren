var e={};(()=>{e.d=(t,r)=>{for(var n in r){if(e.o(r,n)&&!e.o(t,n)){Object.defineProperty(t,n,{enumerable:true,get:r[n]})}}}})();(()=>{e.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)})();if(typeof e!=="undefined")e.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";var t={};e.d(t,{Z:()=>lib});const assert=(e,t="Internal Logic Error")=>{if(!e){throw new Error(typeof t==="function"?t():t)}};class Value{constructor(e,t){this.value=e;this.excluded=t;this.isSimpleStarRec=e==="**";this.isRegexStarRec=e.startsWith("**(")&&e.endsWith(")");this.isStarRec=this.isSimpleStarRec||this.isRegexStarRec}}class Ref{constructor(e,t=null){this.left=t===null;this.link=t===null?new Ref(e,this):t;this.type=e;this.isStarRec=this.type==="**";this.node=null;this.pointer=null}setPointer(e){this.pointer=e;this.link.pointer=e}setNode(e){this.node=e;this.link.node=e}}const throwError=(e,t,r={})=>{throw new Error(Object.entries(r).reduce(((e,[t,r])=>`${e}, ${t} ${r}`),`${e}: ${t}`))};const getSimple=e=>e.length===1?e[0]:e;const r=/^[?*+\d]+$/;const parser_result=e=>{let t=[];t.or=true;let n=false;let s=false;let i=0;const l=[];const newChild=e=>{if(t.excluded===true){assert(s===false);s=true}l.push(t);t=[];t.or=e};const finishChild=()=>{const e=l.pop();const r=getSimple(t);if(e.or===true&&r.or===true){e.push(...r)}else{e.push(r)}t=e};newChild(false);return{setInArray:(t,r)=>{if(n===t){throwError(n?"Bad Array Start":"Bad Array Terminator",e,{char:r})}n=t},finishElement:(l,a,c,{finReq:o=false,group:u=false}={})=>{const f=i===l;if(f){if(!c.includes(e[l-1]||null)){throwError(a,e,{char:l})}i+=1}else{if(o){throwError(a,e,{char:l})}const c=e.slice(i,l);if(u&&!["**","++"].includes(c)){throwError("Bad Group Start",e,{char:l})}if(n&&!(r.test(c)||c.startsWith("(")&&c.endsWith(")"))){throwError("Bad Array Selector",e,{selector:c})}if(u){t.push(new Ref(c))}else{t.push(new Value(n?`[${c}]`:c,s));s=false}i=l+1}},startExclusion:t=>{if(s!==false){throwError("Redundant Exclusion",e,{char:t})}s=true},startGroup:()=>{newChild(true);if(s){t.excluded=true;s=false}newChild(false)},newGroupElement:()=>{finishChild();newChild(false)},finishGroup:r=>{if(l.length<2){throwError("Unexpected Group Terminator",e,{char:r})}finishChild();finishChild();assert(Array.isArray(t));const n=t[t.length-2];if(n instanceof Ref&&n.left===true){t.push(n.link)}},finalizeResult:()=>{finishChild();assert(s===false);if(l.length!==0){throwError("Non Terminated Group",e)}if(n){throwError("Non Terminated Array",e)}return getSimple(t)}}};const parser_throwError=(e,t,r={})=>{throw new Error(Object.entries(r).reduce(((e,[t,r])=>`${e}, ${t} ${r}`),`${e}: ${t}`))};const parse=(e,t)=>{if(e===""){return new Value("",false)}if(Array.isArray(e)){if(e.length===0){return new Value("",false)}return e.map(((r,n)=>{if(typeof r==="number"){if(!t.useArraySelector){parser_throwError("Forbidden Array Selector",JSON.stringify(e),{idx:n})}return new Value(`[${r}]`,false)}return new Value(r.replaceAll("\\","\\\\"),false)}))}const r=parser_result(e);const n=e.length;let s=false;let i=0;for(let l=0;l<n;l+=1){const n=e[l];if(s===false){if(i===0){switch(n){case".":r.finishElement(l,"Bad Path Separator",["]","}"]);break;case"[":if(!t.useArraySelector){parser_throwError("Forbidden Array Selector",e,{char:l})}r.finishElement(l,"Bad Array Start",[null,"!","{",",","}","]"]);r.setInArray(true,l);break;case"]":r.finishElement(l,"Bad Array Terminator",["}"]);r.setInArray(false,l);break;case"{":r.finishElement(l,"Bad Group Start",[null,"!",".","[","{",","],{group:true});r.startGroup();break;case",":r.finishElement(l,"Bad Group Separator",["]","}"]);r.newGroupElement();break;case"}":r.finishElement(l,"Bad Group Terminator",["]","}"]);r.finishGroup(l);break;case"!":r.finishElement(l,"Bad Exclusion",[null,".",",","{","["],{finReq:true});r.startExclusion(l);break;default:break}}switch(n){case"(":i+=1;break;case")":if(i===0){parser_throwError("Unexpected Parentheses",e,{char:l})}i-=1;break;default:break}}s=n==="\\"?!s:false}if(s!==false){parser_throwError("Dangling Escape",e,{char:n-1})}if(i!==0){parser_throwError("Unterminated Parentheses",e)}r.finishElement(n,"Bad Terminator",["]","}"]);return r.finalizeResult()};const n={parse:parse};const iterator=(e,t)=>{const r=[e];const n=[null];const s=[];const i=[];let l=0;let a=true;while(l!==-1){const e=r[l];if(Array.isArray(e)){if(e.or!==true){r.splice(l,1,...e);n.splice(l,1,...new Array(e.length).fill(n[l]));if(n[l]!==null){i[n[l]]+=e.length-1}}else{if(s[l]===undefined){s[l]=0;i[l]=0}else if(i[l]!==0){r.splice(l+1,i[l]);n.splice(l+1,i[l]);i[l]=0}if(s[l]<e.length){r.splice(l+1,0,e[s[l]]);n.splice(l+1,0,l);s[l]=(s[l]||0)+1;i[l]+=1;a=true;l+=1}else{s[l]=0;l-=1}}}else if(a===true){t("ADD",e);if(l===r.length-1){t("FIN",e);a=false}else{l+=1}}else{t("RM",e);l-=1}}};const compiler_iterator=(e,t,r,{onAdd:n,onFin:s})=>{const i=[[[e,null]]];let l=false;iterator(r,((r,a)=>{if(r==="RM"){if(a.excluded===true){l=false}i.length-=2}else if(r==="ADD"){if(a.excluded===true){if(l){throw new Error(`Redundant Exclusion: "${t}"`)}l=true}const e=[];const r=i[i.length-2];i[i.length-1].forEach((([t,s])=>n(t,s,a,r,(r=>e.push([r,t])))));i.push(a,e)}else{i[i.length-1].filter((([t])=>t!==e)).forEach((([e,t])=>s(e,t,a,l)))}}))};const s=/[?!,.*+[\](){}\\]/g;const helper_escape=e=>e.replace(s,"\\$&");const i=/^\^?[^-/\\^$*+?.()|[\]{}]*\$?$/g;const asRegex=e=>{if(i.test(e)){const t=e.startsWith("^");const r=e.endsWith("$");if(t&&r){const t=e.slice(1,-1);return{test:e=>String(e)===t}}if(t){const t=e.slice(1);return{test:e=>String(e).startsWith(t)}}if(r){const t=e.slice(0,-1);return{test:e=>String(e).endsWith(t)}}return{test:t=>String(t).includes(e)}}try{return new RegExp(e)}catch(t){throw new Error(`Invalid Regex: "${e}"`)}};const toPath=e=>e.reduce(((e,t)=>`${e}${typeof t==="number"?`[${t}]`:`${e?".":""}${helper_escape(t)}`}`),"");const formatNeedle=e=>Array.isArray(e)?toPath(e):e;const l=["-","/","\\","^","$","*","+","?",".","(",")","|","[","]","{","}"];const parseValue=e=>{let t="";let r=false;let n=true;for(let s=0;s<e.length;s+=1){const i=e[s];if(!r&&i==="\\"){r=true}else if(!r&&i==="*"){n=false;t+=".*"}else if(!r&&i==="+"){n=false;t+=".+"}else if(!r&&i==="?"){n=false;t+="."}else{if(l.includes(i)){n=false;t+="\\"}t+=i;r=false}}if(n){return{test:e=>String(e)===t}}if(t===".+"){return{test:e=>e!==""}}return new RegExp(`^${t}$`)};const compileValue=e=>{if((e.startsWith("**(")||e.startsWith("++("))&&e.endsWith(")")){return asRegex(e.slice(3,-1))}if(e.startsWith("[(")&&e.endsWith(")]")){return asRegex(e.slice(2,-2))}if(e.startsWith("(")&&e.endsWith(")")){return asRegex(e.slice(1,-1))}if(e.startsWith("[")&&e.endsWith("]")){return parseValue(e.slice(1,-1))}return parseValue(e)};class Node{constructor(e,t){t.nodes.push(this);this.value=e;this.ctx=t;this.order=t.counter;this.children=[];this.match=false;this.matches=false;this.needles=[];this.leafNeedles=[];this.leafNeedlesExclude=[];this.leafNeedlesMatch=[];this.isArrayTarget=e.startsWith("[")&&e.endsWith("]");this.isSimpleStarRec=e==="**";this.isSimplePlusRec=e==="++";this.isSimpleRec=this.isSimpleStarRec||this.isSimplePlusRec;this.isRegexStarRec=e.startsWith("**(")&&e.endsWith(")");this.isRegexPlusRec=e.startsWith("++(")&&e.endsWith(")");this.isStarRec=this.isSimpleStarRec||this.isRegexStarRec;this.isPlusRec=this.isSimplePlusRec||this.isRegexPlusRec;this.isRec=this.isStarRec||this.isPlusRec;this.isAnyArrayTarget=e==="[*]";this.isAnyObjTarget=e==="*";if(this.isSimpleRec||this.isAnyObjTarget||this.isAnyArrayTarget){this.regex=null}else{const{regex:r}=t;if(!(e in r)){r[e]=compileValue(e)}this.regex=r[e]}}recMatch(e){if(!this.isRec){return false}if(this.isSimpleRec){return true}return this.regex.test(e)}typeMatch(e,t){if(this.isSimpleRec){return true}if(this.isAnyArrayTarget){return t}if(this.isAnyObjTarget){return!t}if(t!==this.isArrayTarget&&!this.isRec){return false}return this.regex.test(e)}add(e){this.children.push(e)}get(e){return this.children.find((({value:t})=>t===e))}markMatches(){this.matches=true}addNeedle(e){if(!this.needles.includes(e)){this.needles.push(e)}}setRoots(e){this.roots=e}finish(e,t,r){this.addNeedle(e);if(!this.leafNeedles.includes(e)){this.leafNeedles.push(e)}const n=t?this.leafNeedlesExclude:this.leafNeedlesMatch;if(!n.includes(e)){n.push(e)}this.match=!t;this.matches=this.match;this.index=r}}const applyNeedle=(e,t,r,n)=>{compiler_iterator(e,t,r,{onAdd:(e,r,s,i,l)=>{e.addNeedle(t);if(s instanceof Ref){if(s.left===true){if(s.isStarRec){s.setPointer(e)}s.setNode(new Node("*",n));n.links.push(e,s.node);l(s.node)}else{s.target="target"in i?i.target:r.get(i.value);n.links.push(s.target,s.node);if(s.pointer!==null){l(s.pointer);s.setPointer(null)}l(e)}return}const a=s.isStarRec&&s.value===i?.value;if(a&&n.strict){throw new Error(`Redundant Recursion: "${t}"`)}if(!a){let t=e.get(s.value);if(t===undefined){t=new Node(s.value,n);e.add(t)}l(t)}else{s.target=e}if(s.isStarRec){l(e)}},onFin:(e,r,s,i)=>{if(n.strict&&s.isSimpleStarRec){const e=r.children.filter((({value:e})=>!["","**"].includes(e)));if(e.length!==0){throw new Error(`Needle Target Invalidated: "${e[0].needles[0]}" by "${t}"`)}}if(n.strict&&e.leafNeedles.length!==0){const r=formatNeedle(e.leafNeedles[0]);const n=formatNeedle(t);throw new Error(`Redundant Needle Target: "${r}" vs "${n}"`)}e.finish(t,i,n.counter);n.counter+=1}})};const finalizeTower=(e,t)=>{const{links:r}=t;while(r.length!==0){const e=r.pop();const t=r.pop();const{children:n}=t;t.children=[...e.children.filter((e=>!n.includes(e))),...n]}if(t.useArraySelector===false){e.setRoots(e.children.filter((({isStarRec:e,value:t})=>e||t==="")))}const{nodes:n}=t;while(n.length!==0){const e=n.pop();const{children:t}=e;t.reverse();if(t.some((({matches:e})=>e))){e.markMatches()}}};const compile=(e,t)=>{t.counter=0;t.links=[];t.nodes=[];t.regex=Object.create(null);const r=new Node("*",t);for(let s=0;s<e.length;s+=1){const i=e[s];const l=[n.parse(i,t)];applyNeedle(r,i,l,t)}finalizeTower(r,t);return r};const getUniques=(e,t)=>{const r=[];for(let n=0,s=e.length;n<s;n+=1){const s=e[n][t];for(let e=0,t=s.length;e<t;e+=1){const t=s[e];if(!r.includes(t)){r.push(t)}}}return r};const matchedBy=e=>getUniques(e,"leafNeedlesMatch");const excludedBy=e=>getUniques(e,"leafNeedlesExclude");const traversedBy=e=>getUniques(e,"needles");const isLastLeafMatch=e=>{let t=-1;let r=false;let n=e.length;while(n--){const{index:s,match:i}=e[n];if(s>t){t=s;r=i}}return r};const formatPath=(e,t)=>t?toPath(e):[...e];const find_result=(e,t)=>{if(t.rtn==="context"){return{onMatch:()=>{},get:()=>e.context}}if(t.rtn==="bool"){let e=false;return{onMatch:()=>{e=true},get:()=>e}}if(t.rtn==="count"){let e=0;return{onMatch:()=>{e+=1},get:()=>e}}if(t.rtn==="sum"){let e=0;return{onMatch:({value:t})=>{e+=t},get:()=>e}}const r=[];return{onMatch:(()=>{if(typeof t.rtn==="function"){return()=>r.push(t.rtn(e))}if(Array.isArray(t.rtn)){return()=>r.push(t.rtn.map((t=>e[t])))}return()=>r.push(e[t.rtn])})(),get:()=>t.abort?r[0]:r}};const find=(e,t,r)=>{const n={haystack:e,context:r.context};if(r.beforeFn!==undefined){const e=r.beforeFn(n);if(e!==undefined){n.haystack=e}}const s=[false,[t],null,0];const i=[];const l=[];let a;let c;let o;let u;let f=n.haystack;const h={getKey:(e=r.joined)=>formatPath(i,e),get key(){return h.getKey()},getValue:()=>f,get value(){return h.getValue()},getEntry:(e=r.joined)=>[formatPath(i,e),f],get entry(){return h.getEntry()},getIsMatch:()=>u,get isMatch(){return h.getIsMatch()},getMatchedBy:()=>matchedBy(o),get matchedBy(){return h.getMatchedBy()},getExcludedBy:()=>excludedBy(o),get excludedBy(){return h.getExcludedBy()},getTraversedBy:()=>traversedBy(o),get traversedBy(){return h.getTraversedBy()},getGproperty:()=>i[i.length-2],get gproperty(){return h.getGproperty()},getProperty:()=>i[i.length-1],get property(){return h.getProperty()},getGparent:()=>l[l.length-2],get gparent(){return h.getGparent()},getParent:()=>l[l.length-1],get parent(){return h.getParent()},getParents:()=>[...l].reverse(),get parents(){return h.getParents()},getIsCircular:()=>l.includes(f),get isCircular(){return h.getIsCircular()},getIsLeaf:()=>!(f instanceof Object),get isLeaf(){return h.getIsLeaf()},getDepth:()=>i.length,get depth(){return h.getDepth()},get result(){return h.getResult()},context:n.context};const d=find_result(h,r);h.getResult=()=>d.get();if(r.useArraySelector||!Array.isArray(n.haystack)){const e=t.get("");if(e!==undefined){s[1].push(e)}}do{a=s.pop();c=s.pop();o=s.pop();u=s.pop();const e=i.length-a;for(let t=0;t<e;t+=1){l.pop();i.pop()}if(e===-1){l.push(f);i.push(c);f=f[c]}else if(c!==null){i[i.length-1]=c;f=l[l.length-1][c]}else{f=n.haystack}if(u){if(r.filterFn===undefined||r.filterFn(h)!==false){d.onMatch(h);if(r.abort){s.length=0}}continue}if(!o.some((({matches:e})=>e))){continue}const p=r.useArraySelector===false&&Array.isArray(f);if(!p&&isLastLeafMatch(o)){s.push(true,o,c,a);u=true}if((r.breakFn===undefined||r.breakFn(h)!==true)&&f instanceof Object){const e=Array.isArray(f);const n=e?f.map(((e,t)=>t)).filter((()=>true)):Object.keys(f);if(!e&&r.compareFn){n.sort(r.compareFn(h))}if(!r.reverse){n.reverse()}for(let i=0,l=n.length;i<l;i+=1){const l=n[i];const c=[];if(p){c.push(...o);if(a===0){c.push(...t.roots)}}else{for(let t=0,r=o.length;t!==r;t+=1){const r=o[t];if(r.recMatch(l)){c.push(r)}const{children:n}=r;let s=n.length;while(s--){const t=n[s];if(t.typeMatch(l,e)){c.push(t)}}}}if(r.orderByNeedles){c.index=Buffer.from(c.map((({order:e})=>e)).sort());let e=s.length-3;const t=e-i*4;while(e!==t&&Buffer.compare(c.index,s[e].index)===1){e-=4}s.splice(e+3,0,false,c,l,a+1)}else{s.push(false,c,l,a+1)}}}}while(s.length!==0);n.result=d.get();if(r.afterFn!==undefined){const e=r.afterFn(n);if(e!==undefined){n.result=e}}return n.result};const expect=(e,t,r)=>{assert(r.includes(typeof e[t]),(()=>`Option "${t}" not one of [${r.join(", ")}]`))};const context=e=>{const t={filterFn:undefined,breakFn:undefined,beforeFn:undefined,afterFn:undefined,compareFn:undefined,reverse:true,orderByNeedles:false,abort:false,rtn:undefined,joined:false,useArraySelector:true,strict:true,...e};assert(Object.keys(t).length===12,"Unexpected Option provided");expect(t,"filterFn",["function","undefined"]);expect(t,"breakFn",["function","undefined"]);expect(t,"beforeFn",["function","undefined"]);expect(t,"afterFn",["function","undefined"]);expect(t,"compareFn",["function","undefined"]);expect(t,"reverse",["boolean"]);expect(t,"orderByNeedles",["boolean"]);expect(t,"abort",["boolean"]);assert(typeof t.rtn==="function"&&t.rtn.length===1||[undefined,"context","key","value","entry","property","gproperty","parent","gparent","parents","isMatch","matchedBy","excludedBy","traversedBy","isCircular","isLeaf","depth","bool","count","sum"].includes(t.rtn)||Array.isArray(t.rtn)&&t.rtn.every((e=>["key","value","entry","property","gproperty","parent","gparent","parents","isMatch","matchedBy","excludedBy","traversedBy","isCircular","isLeaf","depth"].includes(e))),'Option "rtn" is malformed');expect(t,"joined",["boolean"]);expect(t,"useArraySelector",["boolean"]);expect(t,"strict",["boolean"]);return t};const lib=(e,t={})=>{assert(Array.isArray(e),'Argument "needles" expected to be Array');assert(t instanceof Object&&!Array.isArray(t),'Argument "opts" expected to be Object');if(e.length===0){return(e,t)=>t===undefined?[]:t}const r=context(t);const n=compile(e,r);return(e,t)=>find(e,n,{context:t,...r,rtn:r.rtn||(t===undefined?"key":"context")})};var a=t.Z;export{a as default};