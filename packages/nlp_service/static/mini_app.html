<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FreiFahren Mini App</title>
    <style>
        :root {
            --padding-m: 16px;
            --padding-s: 12px;
            --padding-xs: 8px;
            --margin-l: 16px;
            --margin-m: 12px;
            --margin-s: 8px;
            --margin-xs: 4px;
            --margin-xxs: 2px;
            --font-l: 1.125rem; /* 18px */
            --font-m: 1rem;    /* 16px */
            --font-s: 0.875rem; /* 14px */
            --font-xs: 0.75rem;  /* 12px */
            --font-xxs: 0.625rem;/* 10px */
            --transition-default: 0.2s;
            --line-height: 36px;
            --item-height: 37px; /* Corresponds to ITEM_HEIGHT in React */
            --border-radius-s: 4px;
            --border-radius-m: 8px;
            --border-radius-l: 18px; /* For circular elements */
            --tg-theme-secondary-bg-color: #f0f0f0; /* Define a fallback */
            --tg-theme-hint-color: #999999; /* Define a fallback */
            --tg-theme-button-color: #2481cc; /* Define a fallback */
            --tg-theme-button-text-color: #ffffff; /* Define a fallback */
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            color: var(--tg-theme-text-color, #000000);
            background-color: var(--tg-theme-bg-color, #ffffff);
            font-size: var(--font-m);
            overscroll-behavior: none; /* Prevent pull-to-refresh issues */
        }

        .report-form {
            padding: var(--padding-m);
            transition: ease-in-out var(--transition-default);
            padding-bottom: var(--padding-xs);
            max-width: 500px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Allow dynamic height calculations */
            box-sizing: border-box;
        }

        .report-form form {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        
        .report-form form > div {
           flex-grow: 1;
           display: flex;
           flex-direction: column;
        }

        #top-elements, #bottom-elements {
            padding: 0;
            margin: 0;
        }

        #top-elements section > *,
        #bottom-elements section > * {
            margin-top: var(--margin-s);
            margin-bottom: var(--margin-s);
        }
        
        h1 { font-size: var(--font-l); font-weight: bold; margin: var(--margin-m) 0; }
        h2 { font-size: var(--font-m); font-weight: bold; margin: var(--margin-s) 0; }
        h3 { font-size: var(--font-s); font-weight: bold; margin: var(--margin-s) 0; }
        
        section {
            margin-bottom: var(--margin-m);
        }
        
        .align-child-on-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--margin-s);
        }
        
        /* SelectField Simulation */
        .select-field-container {
            display: flex;
            gap: var(--margin-s);
            overflow-x: auto;
            padding: var(--padding-xs) 0;
            scrollbar-width: none; /* Firefox */
        }
        .select-field-container::-webkit-scrollbar {
            display: none; /* Safari and Chrome */
        }

        .select-field-container.large-selector .select-field-option {
            min-width: var(--line-height);
            height: var(--line-height);
            border-radius: var(--border-radius-l);
            font-size: var(--font-l);
        }
        
        .select-field-option {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--padding-xs) var(--padding-s);
            border: 1px solid var(--tg-theme-hint-color, #cccccc);
            border-radius: var(--border-radius-m);
            cursor: pointer;
            transition: background-color var(--transition-default), border-color var(--transition-default);
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            white-space: nowrap;
            opacity: 0.7;
            font-weight: bold;
        }

        .select-field-option.selected {
            background-color: var(--tg-theme-button-color, #2481cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            border-color: var(--tg-theme-button-color, #2481cc);
            opacity: 1;
        }

        .line { /* Mimic Line component style */
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: var(--line-height);
            height: var(--line-height);
            border-radius: var(--border-radius-l);
            color: white;
            font-weight: bold;
            padding: 0 var(--padding-xs); /* Adjust padding */
            box-sizing: border-box;
        }

        /* Autocomplete Simulation */
        .autocomplete-container {
            position: relative;
            margin-top: var(--margin-s);
            flex-grow: 1; /* Allows list to take available space */
            display: flex; /* Needed for height calculation */
            flex-direction: column; /* Needed for height calculation */
            min-height: calc(var(--item-height) + 2*var(--padding-s)); /* Ensure space for input */
        }
        
        .autocomplete-container label {
             font-weight: bold;
             margin-bottom: var(--margin-xs);
             display: block;
        }

        .autocomplete-container input {
            margin-bottom: var(--margin-xxs); /* Space between input and list */
        }
        
        .autocomplete-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            border: 1px solid var(--tg-theme-hint-color, #cccccc);
            border-radius: var(--border-radius-m);
            background-color: var(--tg-theme-bg-color, #ffffff);
            max-height: 200px; /* Default max height, will be adjusted */
        }
        
        .autocomplete-list li {
            padding: var(--padding-s);
            cursor: pointer;
            border-bottom: 1px solid var(--tg-theme-secondary-bg-color, #f0f0f0);
            height: var(--item-height);
            box-sizing: border-box;
            display: flex;
            align-items: center;
        }
        
        .autocomplete-list li:last-child {
            border-bottom: none;
        }
        
        .autocomplete-list li:hover, .autocomplete-list li.highlighted {
            background-color: var(--tg-theme-secondary-bg-color, #f0f0f0);
        }
        
        input, select, textarea {
            width: 100%;
            padding: var(--padding-s);
            border: 1px solid var(--tg-theme-hint-color, #cccccc);
            border-radius: var(--border-radius-m);
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            box-sizing: border-box;
            font-size: var(--font-m);
            margin-top: var(--margin-xs);
        }
        
        textarea {
            min-height: 60px; /* Adjusted default */
            resize: vertical;
        }
        
        .privacy-checkbox-container {
            display: flex;
            align-items: center;
            font-size: var(--font-xs);
            margin: var(--margin-m) 0;
        }
        
        .privacy-checkbox-container input {
            width: auto;
            margin-right: var(--margin-s);
            margin-top: 0; /* Override default */
            height: var(--font-xs); /* Match font size */
            flex-shrink: 0;
        }
         .privacy-checkbox-container label {
            line-height: 1.3;
         }

        .submit-button {
            background-color: var(--tg-theme-button-color, #2481cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            border-radius: var(--border-radius-m);
            padding: var(--padding-s) var(--padding-m);
            font-size: var(--font-m);
            font-weight: 500;
            cursor: pointer;
            width: 100%;
            margin-top: var(--margin-m);
            transition: background-color var(--transition-default);
        }
        
        .submit-button.button-gray {
            background-color: var(--tg-theme-secondary-bg-color, #cccccc);
            color: var(--tg-theme-hint-color, #666666);
            cursor: not-allowed;
        }
        
        .disclaimer {
            font-size: var(--font-xs);
            color: var(--tg-theme-hint-color, #999999);
            text-align: center;
            margin-top: var(--margin-s);
        }

        .warning-span {
            color: red;
            font-size: var(--font-xs);
            margin-top: var(--margin-xs);
            display: block;
        }
        
        /* Utility */
        .hidden {
            display: none !important;
        }

        @media (max-width: 375px) {
           .privacy-checkbox-container {
               font-size: var(--font-xxs);
           }
            textarea {
                min-height: 40px;
            }
            h1 { font-size: 1.1rem; } /* Slightly smaller */
            .select-field-container.large-selector .select-field-option {
                min-width: 32px;
                height: 32px;
                font-size: var(--font-m);
            }
            .line {
                 min-width: 32px;
                 height: 32px;
            }
        }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
    <div class="container report-form" id="report-form-container">
        <form id="report-form">
             <!-- This div structure helps with flexbox layout -->
             <div>
                <div id="top-elements">
                    <div class="align-child-on-line">
                        <h1>Report Control</h1>
                        <!-- Feedback button omitted for now -->
                    </div>
                    
                    <section>
                        <!-- Entity Selector -->
                        <div id="entity-selector" class="select-field-container large-selector">
                            <div class="select-field-option line" style="background-color: #0a6ebd;" data-value="U"><strong>U</strong></div>
                            <div class="select-field-option line" style="background-color: #006b53;" data-value="S"><strong>S</strong></div>
                            <div class="select-field-option line" style="background-color: #bf4700;" data-value="M"><strong>M</strong></div>
                        </div>
                    </section>
                    
                    <section id="line-section">
                        <h2>Line</h2>
                        <!-- Line Selector -->
                        <div id="line-selector" class="select-field-container long-selector">
                            <!-- Line options will be populated here -->
                            <span style="color: var(--tg-theme-hint-color); font-size: var(--font-s);">Select transport type first</span>
                        </div>
                    </section>
                </div>
                
                <!-- Autocomplete Station Input -->
                <div class="autocomplete-container" id="autocomplete-station-container">
                    <label for="station-input">Station</label>
                    <input type="text" id="station-input" placeholder="Search for a station" autocomplete="off" required>
                    <ul id="station-list" class="autocomplete-list hidden"></ul>
                     <span class="warning-span" id="station-warning"></span>
                </div>

                <div id="bottom-elements">
                    <section id="direction-section" class="hidden">
                        <h3>Direction</h3>
                        <!-- Direction Selector -->
                         <div id="direction-selector" class="select-field-container">
                             <!-- Direction options will be populated here -->
                         </div>
                    </section>
                    
                    <section id="description-section" class="description-field hidden">
                        <h3>Description</h3>
                        <textarea id="description-input" placeholder="Add any additional information..."></textarea>
                    </section>
                    
                    <section id="final-section" class="hidden">
                        <div class="privacy-checkbox-container">
                            <input type="checkbox" id="privacy-checkbox">
                            <label for="privacy-checkbox" id="privacy-label">I agree to the privacy policy and terms of service</label>
                        </div>
                        <span class="warning-span" id="privacy-warning"></span>
                        
                        <div>
                            <button type="submit" id="submit-button" class="submit-button button-gray" disabled>Report</button>
                            <p class="disclaimer">Your report will be synchronized when online</p>
                        </div>
                    </section>
                 </div>
             </div>
        </form>
    </div>

    <script>
        const tg = window.Telegram.WebApp;
        tg.expand(); 
        
        tg.MainButton.setText('CLOSE');
        tg.MainButton.onClick(() => tg.close());
        tg.MainButton.show();

        // --- DOM Elements ---
        const form = document.getElementById('report-form');
        const entitySelector = document.getElementById('entity-selector');
        const lineSelector = document.getElementById('line-selector');
        const stationInput = document.getElementById('station-input');
        const stationList = document.getElementById('station-list');
        const stationWarning = document.getElementById('station-warning');
        const directionSelector = document.getElementById('direction-selector');
        const descriptionInput = document.getElementById('description-input');
        const privacyCheckbox = document.getElementById('privacy-checkbox');
        const privacyLabel = document.getElementById('privacy-label');
        const privacyWarning = document.getElementById('privacy-warning');
        const submitButton = document.getElementById('submit-button');
        
        const lineSection = document.getElementById('line-section');
        const directionSection = document.getElementById('direction-section');
        const descriptionSection = document.getElementById('description-section');
        const finalSection = document.getElementById('final-section');

        const autocompleteContainer = document.getElementById('autocomplete-station-container');
        const topElements = document.getElementById('top-elements');
        const bottomElements = document.getElementById('bottom-elements');
        const formContainer = document.getElementById('report-form-container');

        // --- State ---
        const formState = {
            entity: null,
            line: null,
            station: null, // Stores the selected station object {id: '...', name: '...'}
            direction: null, // Stores the selected direction station object {id: '...', name: '...'}
            description: '',
            privacyChecked: false
        };

        // --- Simulated Data (Replace with actual API fetch) ---
        // TODO: Replace with actual fetch from backend/API
        const allStations = {
            "S_Alexanderplatz": { name: "S Alexanderplatz", lines: ["S3", "S5", "S7", "S8"], coordinates: {latitude: 52.5215, longitude: 13.4111} },
            "U_Alexanderplatz": { name: "U Alexanderplatz", lines: ["U2", "U5", "U8"], coordinates: {latitude: 52.5219, longitude: 13.4132} },
            "S_Friedrichstr": { name: "S+U Friedrichstr.", lines: ["S1", "S2", "S3", "S5", "S7", "S25", "U6"], coordinates: {latitude: 52.5202, longitude: 13.3870} },
            "U_Kurfuerstendamm": { name: "U Kurfürstendamm", lines: ["U1", "U9"], coordinates: {latitude: 52.5039, longitude: 13.3320} },
            "S_Hauptbahnhof": { name: "S+U Hauptbahnhof", lines: ["S3", "S5", "S7", "S9", "U5"], coordinates: {latitude: 52.5251, longitude: 13.3694} },
             "S_Warschauer": { name: "S+U Warschauer Str.", lines: ["S3", "S5", "S7", "S9", "U1", "U3", "M10"], coordinates: { latitude: 52.505, longitude: 13.449 } },
             "M_Warschauer": { name: "S+U Warschauer Str. (M)", lines: ["M10"], coordinates: { latitude: 52.505, longitude: 13.449 } }, // Tram stop might have diff ID
             "S_Ostkreuz": { name: "S Ostkreuz", lines: ["S3", "S5", "S7", "S8", "S41", "S42", "S75", "S85"], coordinates: { latitude: 52.503, longitude: 13.469 } },
             "U_Kottbusser_Tor": { name: "U Kottbusser Tor", lines: ["U1", "U3", "U8"], coordinates: { latitude: 52.499, longitude: 13.418 } },
        };

        const allLines = {
            "U1": ["U_Kurfuerstendamm", "U_Kottbusser_Tor", "S_Warschauer"],
            "U2": ["U_Alexanderplatz"],
            "U3": ["U_Kottbusser_Tor", "S_Warschauer"],
            "U5": ["S_Hauptbahnhof", "U_Alexanderplatz"],
            "U6": ["S_Friedrichstr"],
            "U8": ["U_Alexanderplatz", "U_Kottbusser_Tor"],
            "U9": ["U_Kurfuerstendamm"],
            "S1": ["S_Friedrichstr"],
            "S2": ["S_Friedrichstr"],
            "S3": ["S_Alexanderplatz", "S_Friedrichstr", "S_Hauptbahnhof", "S_Warschauer", "S_Ostkreuz"],
            "S5": ["S_Alexanderplatz", "S_Friedrichstr", "S_Hauptbahnhof", "S_Warschauer", "S_Ostkreuz"],
            "S7": ["S_Alexanderplatz", "S_Friedrichstr", "S_Hauptbahnhof", "S_Warschauer", "S_Ostkreuz"],
            "S8": ["S_Alexanderplatz", "S_Ostkreuz"],
            "S9": ["S_Hauptbahnhof", "S_Warschauer"], // Added S9 example
            "S25": ["S_Friedrichstr"],
            "S41": ["S_Ostkreuz"], // Ringbahn example
            "S42": ["S_Ostkreuz"], // Ringbahn example
            "M10": ["S_Warschauer", "M_Warschauer"]
        };
        // --- End Simulated Data ---

        // --- Helper Functions ---
        function getLineColor(line) {
            if (!line) return '#808080'; // Default gray
            if (line.startsWith('U')) return '#0a6ebd';
            if (line.startsWith('S')) return '#006b53';
            if (line.startsWith('M')) return '#bf4700'; // Tram/Metrotram
            if (line.startsWith('T')) return '#6a3e9e'; // Tram
            if (line.startsWith('F')) return '#008cd1'; // Ferry
            if (line.startsWith('B') || line.match(/^[0-9]+$/)) return '#a50317'; // Bus
            return '#808080';
        }

        function createOptionElement(value, text, type, isSelected = false, style = {}) {
             const el = document.createElement('div');
             el.dataset.value = value;
             el.classList.add('select-field-option');
             if (type === 'entity' || type === 'line') {
                 el.classList.add('line'); // Use line styling for these
                 el.style.backgroundColor = getLineColor(value);
                 el.innerHTML = `<strong>${text}</strong>`;
             } else { // Direction
                 el.textContent = text;
             }
             if (isSelected) {
                 el.classList.add('selected');
             }
             Object.assign(el.style, style);
             return el;
        }
        
        function clearSelector(selectorElement) {
            selectorElement.innerHTML = '';
        }

        function populateSelector(selectorElement, options, type, selectedValue = null, valueKey = 'value', textKey = 'text') {
            clearSelector(selectorElement);
            if (!options || options.length === 0) {
                 selectorElement.innerHTML = `<span style="color: var(--tg-theme-hint-color); font-size: var(--font-s);">No options available</span>`;
                 return;
            }
            options.forEach(optionData => {
                const value = typeof optionData === 'string' ? optionData : optionData[valueKey];
                const text = typeof optionData === 'string' ? optionData : optionData[textKey];
                const isSelected = value === selectedValue;
                const element = createOptionElement(value, text, type, isSelected);
                element.addEventListener('click', () => handleSelection(selectorElement.id, value));
                selectorElement.appendChild(element);
            });
            // Re-select the currently selected one visually
             updateSelectorSelection(selectorElement.id, selectedValue);
        }
        
        function updateSelectorSelection(selectorId, selectedValue) {
            const selectorElement = document.getElementById(selectorId);
            selectorElement.querySelectorAll('.select-field-option').forEach(opt => {
                 if (opt.dataset.value === selectedValue) {
                     opt.classList.add('selected');
                     // Scroll into view if needed
                     opt.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                 } else {
                     opt.classList.remove('selected');
                 }
            });
        }

         function calculateAndSetListHeight() {
            requestAnimationFrame(() => { // Ensure layout is calculated
                const ITEM_HEIGHT_CSS = 37; // Should match --item-height or actual li height
                const PADDING_S_CSS = 8; // Should match --padding-s

                if (formContainer && topElements && bottomElements && autocompleteContainer) {
                    const containerHeight = formContainer.clientHeight;
                    const topHeight = topElements.offsetHeight;
                    const bottomHeight = bottomElements.offsetHeight;
                    const inputHeight = stationInput.offsetHeight;
                    const labelHeight = autocompleteContainer.querySelector('label')?.offsetHeight ?? 0;
                    const inputMargin = parseFloat(getComputedStyle(stationInput).marginBottom);
                    const labelMargin = parseFloat(getComputedStyle(autocompleteContainer.querySelector('label')).marginBottom);
                    const sectionMargin = parseFloat(getComputedStyle(lineSection).marginBottom) * 2; // Approx margin for autocomplete section too

                    const availableHeight = containerHeight - topHeight - bottomHeight - inputHeight - labelHeight - inputMargin - labelMargin - sectionMargin - (PADDING_S_CSS * 4) ; // Extra padding buffer

                    const currentStationCount = stationList.children.length;
                    const potentialListHeight = currentStationCount * ITEM_HEIGHT_CSS;
                    
                    const newHeight = Math.max(ITEM_HEIGHT_CSS, Math.min(potentialListHeight, availableHeight));

                    stationList.style.maxHeight = `${newHeight}px`;
                    console.log("Calculated Max Height:", newHeight, "Available:", availableHeight);
                }
            });
        }

        // --- Event Handlers ---
        function handleSelection(selectorId, value) {
            console.log("Selected:", selectorId, value);
            switch (selectorId) {
                case 'entity-selector':
                    if (formState.entity === value) {
                         formState.entity = null; // Deselect
                         formState.line = null;
                         formState.station = null;
                         formState.direction = null;
                         clearSelector(lineSelector);
                         lineSelector.innerHTML = `<span style="color: var(--tg-theme-hint-color); font-size: var(--font-s);">Select transport type first</span>`;
                         directionSection.classList.add('hidden');
                    } else {
                        formState.entity = value;
                        updateSelectorSelection(selectorId, value);
                         // Check if current line is still valid
                         if (formState.line && !formState.line.startsWith(formState.entity)) {
                             formState.line = null;
                             formState.station = null;
                             formState.direction = null;
                             directionSection.classList.add('hidden');
                         }
                         // Check if current station is still valid
                         if (formState.station && allStations[formState.station.id]) {
                             const stationData = allStations[formState.station.id];
                             if (!stationData.lines.some(l => l.startsWith(formState.entity))) {
                                 formState.station = null;
                                 formState.direction = null;
                                 stationInput.value = '';
                                 directionSection.classList.add('hidden');
                             }
                         }
                        populateLineSelector();
                    }
                    break;
                case 'line-selector':
                     if (formState.line === value) {
                         formState.line = null; // Deselect
                         formState.station = null;
                         formState.direction = null;
                         stationInput.value = '';
                         directionSection.classList.add('hidden');
                     } else {
                         formState.line = value;
                         updateSelectorSelection(selectorId, value);
                         // If station selected, check if it's on the new line
                         if (formState.station && !(allLines[formState.line] || []).includes(formState.station.id)) {
                             formState.station = null;
                             formState.direction = null;
                             stationInput.value = '';
                         }
                         updateDirectionSelectorVisibility(); // Show/hide based on line (e.g., S41/S42)
                     }
                    break;
                 case 'direction-selector':
                     if (formState.direction?.id === value) { // Check against stored ID
                         formState.direction = null; // Deselect
                     } else {
                         formState.direction = { id: value, name: allStations[value]?.name || value };
                         updateSelectorSelection(selectorId, value);
                     }
                    break;
            }
            validateForm();
             filterAndDisplayStations(); // Refilter stations based on new entity/line
            updateSelectorSelection(selectorId, selectorId.includes('entity') ? formState.entity : (selectorId.includes('line') ? formState.line : formState.direction?.id));
            calculateAndSetListHeight(); // Recalculate on selection changes
        }

        function populateLineSelector() {
            if (!formState.entity) {
                 clearSelector(lineSelector);
                 lineSelector.innerHTML = `<span style="color: var(--tg-theme-hint-color); font-size: var(--font-s);">Select transport type first</span>`;
                 return;
            }
            const linesForEntity = Object.keys(allLines).filter(line => line.startsWith(formState.entity));
             linesForEntity.sort(); // Sort lines alphabetically/numerically
            populateSelector(lineSelector, linesForEntity, 'line', formState.line);
        }
        
        function updateDirectionSelectorVisibility() {
             const line = formState.line;
             const stationSelected = !!formState.station;
             if (stationSelected && line && line !== 'S41' && line !== 'S42') {
                 directionSection.classList.remove('hidden');
                 populateDirectionSelector();
             } else {
                 directionSection.classList.add('hidden');
                 formState.direction = null; // Reset direction if hidden
             }
        }

        function populateDirectionSelector() {
            if (!formState.line || !allLines[formState.line] || allLines[formState.line].length < 2) {
                 clearSelector(directionSelector);
                 directionSelector.innerHTML = `<span style="color: var(--tg-theme-hint-color); font-size: var(--font-s);">Not available</span>`;
                 return;
            }
            
            const lineStations = allLines[formState.line];
            const firstStationId = lineStations[0];
            const lastStationId = lineStations[lineStations.length - 1];
            
            const directions = [
                 { value: firstStationId, text: allStations[firstStationId]?.name || firstStationId },
                 { value: lastStationId, text: allStations[lastStationId]?.name || lastStationId }
            ];
            
            populateSelector(directionSelector, directions, 'direction', formState.direction?.id, 'value', 'text');
        }

         function filterAndDisplayStations() {
            const searchTerm = stationInput.value.toLowerCase();
            stationList.innerHTML = ''; // Clear previous results
            stationWarning.textContent = ''; // Clear warning

            let filteredStations = Object.entries(allStations);

            // Filter by entity
             if (formState.entity) {
                 filteredStations = filteredStations.filter(([id, data]) =>
                     data.lines.some(l => l.startsWith(formState.entity))
                 );
             }

            // Filter by line
            if (formState.line) {
                 const stationsOnLine = allLines[formState.line] || [];
                 filteredStations = filteredStations.filter(([id]) => stationsOnLine.includes(id));
            }

            // Filter by search term
            if (searchTerm) {
                 filteredStations = filteredStations.filter(([id, data]) =>
                     data.name.toLowerCase().includes(searchTerm)
                 );
            } else if (formState.station) {
                 // If a station is selected and input is cleared, show only the selected one initially
                 filteredStations = filteredStations.filter(([id]) => id === formState.station.id);
            }

            // Sort results alphabetically
             filteredStations.sort(([,a], [,b]) => a.name.localeCompare(b.name));

            if (filteredStations.length === 0 && searchTerm) {
                 stationWarning.textContent = 'No stations found matching your search.';
            }

            filteredStations.forEach(([id, data]) => {
                const li = document.createElement('li');
                li.textContent = data.name;
                li.dataset.stationId = id;
                li.dataset.stationName = data.name;
                li.addEventListener('click', () => {
                    stationInput.value = data.name;
                    formState.station = { id: id, name: data.name };
                    stationList.classList.add('hidden');
                    updateDirectionSelectorVisibility();
                     descriptionSection.classList.remove('hidden');
                     finalSection.classList.remove('hidden');
                    validateForm();
                    calculateAndSetListHeight(); // Recalculate on selection
                });
                stationList.appendChild(li);
            });

            if (filteredStations.length > 0 && document.activeElement === stationInput) {
                 stationList.classList.remove('hidden');
            } else {
                 stationList.classList.add('hidden');
            }
             calculateAndSetListHeight(); // Recalculate after populating
        }

        stationInput.addEventListener('input', () => {
            formState.station = null; // Clear selection when user types
            formState.direction = null; // Clear direction too
             directionSection.classList.add('hidden');
             descriptionSection.classList.add('hidden');
             finalSection.classList.add('hidden');
            filterAndDisplayStations();
            validateForm();
        });

         stationInput.addEventListener('focus', () => {
             // Show list only if there are items or if it's empty but ready for typing
             if (stationList.children.length > 0 || stationInput.value === '') {
                stationList.classList.remove('hidden');
                 calculateAndSetListHeight(); // Ensure correct height on focus
             }
         });

         // Debounce blur event to allow clicks on the list
         let blurTimeout;
         stationInput.addEventListener('blur', () => {
             clearTimeout(blurTimeout);
             blurTimeout = setTimeout(() => {
                 stationList.classList.add('hidden');
             }, 150); // Delay to allow click event on list items
         });


        descriptionInput.addEventListener('input', (e) => {
            formState.description = e.target.value;
            // No validation change needed based on description alone
        });

        privacyCheckbox.addEventListener('change', (e) => {
            formState.privacyChecked = e.target.checked;
            privacyWarning.textContent = ''; // Clear warning on interaction
            validateForm();
        });

        function validateForm() {
             // Basic validation: line and station must be selected, privacy must be checked.
             const isLineSelected = !!formState.line;
             const isStationSelected = !!formState.station; // Check if the station object is set
             const isPrivacyChecked = formState.privacyChecked;

             // Direction is only required if the section is visible
             const isDirectionRequired = !directionSection.classList.contains('hidden');
             const isDirectionSelected = !!formState.direction;
             
             const isValid = isLineSelected && isStationSelected && isPrivacyChecked && (!isDirectionRequired || isDirectionSelected);

            if (isValid) {
                submitButton.disabled = false;
                submitButton.classList.remove('button-gray');
            } else {
                submitButton.disabled = true;
                submitButton.classList.add('button-gray');
            }
            
            return isValid;
        }
        
        function highlightError(element, warningElement, message) {
             if (element) element.style.outline = '1px solid red'; // Simple highlight
             if (warningElement) warningElement.textContent = message;
        }
        
        function clearErrorHighlight() {
             [stationInput, privacyLabel].forEach(el => {
                 if(el) el.style.outline = 'none';
             });
             [stationWarning, privacyWarning].forEach(el => {
                  if(el) el.textContent = '';
             });
             // Add logic for line/entity/direction selectors if needed
        }

        form.addEventListener('submit', (e) => {
            e.preventDefault();
             clearErrorHighlight(); // Clear previous errors

            let hasError = false;

             // Check required fields again explicitly for error messages
             if (!formState.line) {
                  // Highlight line selector somehow? Maybe the H2?
                  hasError = true;
                  tg.showAlert("Please select a line."); // Simple alert for now
                  return;
             }
             if (!formState.station) {
                  highlightError(stationInput, stationWarning, "Please select a station from the list.");
                  hasError = true;
             }
             if (!directionSection.classList.contains('hidden') && !formState.direction) {
                 // Highlight direction selector?
                 hasError = true;
                 tg.showAlert("Please select a direction."); // Simple alert
                 return;
             }
             if (!formState.privacyChecked) {
                  highlightError(privacyLabel, privacyWarning, "Please agree to the privacy policy.");
                  hasError = true;
             }

             if (hasError) {
                 tg.HapticFeedback.notificationOccurred('error');
                 return;
             }
            
            // Prepare data
            const data = {
                entity: formState.entity,
                line: formState.line,
                station: formState.station, // Send object {id, name}
                direction: formState.direction, // Send object {id, name} or null
                description: formState.description.trim()
            };
            
            console.log("Submitting data:", data);
            tg.sendData(JSON.stringify(data));
            
            tg.showPopup({
                title: 'Report Submitted',
                message: 'Thank you for your report!',
                buttons: [{type: 'ok'}]
            }, () => {
                 // Optional: Close after OK. Consider if user might want to submit another.
                 // tg.close(); 
            });
             tg.HapticFeedback.notificationOccurred('success');
        });
        
         // Initial Setup
         filterAndDisplayStations(); // Initial population (likely empty)
         validateForm(); // Set initial button state

         // Adjust list height on resize
         window.addEventListener('resize', calculateAndSetListHeight);
         // Initial calculation
         setTimeout(calculateAndSetListHeight, 100); // Delay slightly for layout

          // Add listener to recalculate height when keyboard appears/disappears
          // This uses the VisualViewport API if available
          if (window.visualViewport) {
              window.visualViewport.addEventListener('resize', calculateAndSetListHeight);
          }

    </script>
</body>
</html> 